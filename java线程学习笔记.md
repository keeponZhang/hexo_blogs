---
title: java线程学习笔记
date: 2016-06-23 13:58:14
tags:
---
### sleep()
sleep()方法是类方法,也就是对当前线程而言的,程序员不能指定某个线程去sleep,只能是当前线程执行到sleep()方法时,睡眠指定的时间(让其它线程运行).事实上也只能是类方法,在当前线程上调用.试想如果你调用一个线程对象的sleep()方法,那么这个对象对应的线程如果不是正在运行,它如何sleep()?

所以只有当前线程,才能保证它可以调用sleep()方法，因为它正在执行。

调用sleep()的线程不会释放当前所获得的锁对象。

### yield()
yield()方法也是类方法,只在当前线程上调用,理由同上,它主是让当前线程放弃本次分配到的时间片。

### synchornized

把一个单元声明为synchronized,就可以让在同一时间只有一个线程执行该单元块中的代码。

每个对象有且只有一把监视锁(monitor lock)，一次只能被一个线程获取。当一个线程获取了这一个锁
后,这段时间只有这个线程才能执行该synchronized块中代码,其它线程就只能等待这个线程释放锁后才能再获取.
    
    //对于同步块,synchronized获取的是参数中的对象锁:
    synchronized(obj){
        //...............
    }
因为只有对象类型才有对象锁，原始类型是没有对象锁的。所以synchronized括号中的参数只能是对象，不能是原始类型。

### wait() 和notify()/notifyAll()

**这三个方法是Object类的方法，不是Thread类的方法。**

当一个线程调用了一个对象的wait方法后,这个线程就进入了这个对象的休息室(waitset),这是一个虚拟的
对象,但JVM中一定存在这样的一个数据结构用来记录当前对象的休息室中有哪些线程在等待.
当一个线程进入等待时,它就会释放锁,让其它线程来获取这个锁. **进入对象休息室中的线程，只能让其它线程调用同一个对象的notify()/notifyAll()方法。**

调用这三个对象的方法的线程必须要获得这三个对象的锁，否则会抛出java.lang.IllegalMonitorStateException异常。

所以请记住:

> 线程要想调用一个对象的wait()方法就要先获得该对象的监视锁,而一旦调用wait()后又立即自动释放该锁


notofy/notifyAll方法也必须在同步代码块中调用(也就是调用线程必须持有对象的锁)，他们的功能是这样的：

> 女士们，先生们请注意，锁的对象我即将用完，请大家醒醒，准备一下，马上你们就能使用锁了。

不同的是，notify方法只会唤醒一个正在等待的线程(至于唤醒谁，不确定！)，而notifyAll方法会唤醒所有正在等待的线程。还有一点需要特别强调：**调用notify和notifyAll方法后，当前线程并不会立即放弃锁的持有权，而必须要等待当前同步代码块执行完才会让出锁**。

### 线程中断
在以前的版本中，使用stop(),suspend()强制让线程停止或者挂起，这会导致一些意想不到的结果出现。所以在新版本的JDK中这几个方法已经被标记为Deprecated。

在新版本中在java中,线程的中断(interrupt)只是改变了线程的中断状态,至于这个中断状态改变后带来的结果,那是无法确定的,有时它更是让停止中的线程继续执行的唯一手段.不但不是让线程停止运行,反而是继续执行线程的手段.

在一个线程对象上调用interrupt()方法,真正有影响的是wait,join,sleep方法,当然这三个方法包括它们的重载方法.

* 对于wait中等待notify/notifyAll唤醒的线程,其实这个线程已经"暂停"执行,因为它正在某一对象的休息室中,这时如果它的中断状态被改变,那么它就会抛出InterruptedException异常.这个InterruptedException异常不是线程抛出的,而是wait方法,也就是对象的wait方法内部会不断检查在此对象上休息的线程的状态,如果发现哪个线程的状态被置为已中断,则会抛出InterruptedException,意思就是这个线程不能再等待了,其意义就等同于唤醒它了.

* 对于sleep中的线程,如果你调用了Thread.sleep(一年);现在你后悔了,想让它早些醒过来,调用
interrupt()方法就是唯一手段,只有改变它的中断状态,让它从sleep中将控制权转到处理异常的catch语句中,然后再由catch中的处理转换到正常的逻辑.同样,地于join中的线程你也可以这样处理. 

 对于一般介绍多线程模式的书上,他们会这样来介绍:当一个线程被中断后,在进入wait,sleep,join方法时会抛出异常.是的,这一点也没有错,但是这有什么意义呢?如果你知道那个线程的状态已经处于中断状态,为什么还要让它进入这三个方法呢?

在已经调用wait,join,sleep这三个方法的线程上调用interrupt()方法会让线程从这几个方法的"暂停"状态中恢复过来.这个恢复过来就可以包含两个目的:

1. [可以使线程继续执行],那就是在catch语句中执行醒来后的逻辑,或由catch语句转回正常的逻辑.总之它是从wait,sleep,join的暂停状态活过来了.

2. [可以直接停止线程的运行],当然在catch中什么也不处理,或return,那么就完成了当前线程的使命,可以使在上面"暂停"的状态中立即真正的"停止".